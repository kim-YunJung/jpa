## Me
백엔드로는 jpa와 자바 / 프론트엔드로는 react를 사용한 게시판을 만들어줘.

## AI Assistant
React와 Spring Boot(JPA)를 활용해 게시판 애플리케이션을 만드는 간단한 예제를 소개해드리겠습니다. 이 게시판에는 CRUD(Create, Read, Update, Delete) 기능을 포함하며, 백엔드는 Spring Boot로, 프론트엔드는 React로 구현됩니다.

---

### 1. **백엔드: Spring Boot로 게시판 API 만들기**

#### 엔티티 설계 (Java - JPA 사용)
```java
package jpabook.jpashop.domain;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    @Lob // 길이 제한 없는 본문
    private String content;

    private String author;

    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;

    @PrePersist
    public void prePersist() {
        this.createdAt = LocalDateTime.now();
    }

    @PreUpdate
    public void preUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

#### Repository (데이터베이스 연동)
```java
package jpabook.jpashop.repository;

import jpabook.jpashop.domain.Post;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PostRepository extends JpaRepository<Post, Long> {
}
```

#### Service (비즈니스 로직 처리)
```java
package jpabook.jpashop.service;

import jpabook.jpashop.domain.Post;
import jpabook.jpashop.repository.PostRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class PostService {

    private final PostRepository postRepository;

    public List<Post> findAllPosts() {
        return postRepository.findAll();
    }

    public Post findPostById(Long id) {
        return postRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("Post not found"));
    }

    public Post savePost(Post post) {
        return postRepository.save(post);
    }

    public void deletePost(Long id) {
        postRepository.deleteById(id);
    }
}
```

#### Controller (API 생성)
```java
package jpabook.jpashop.api;

import jpabook.jpashop.domain.Post;
import jpabook.jpashop.service.PostService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostApiController {

    private final PostService postService;

    @GetMapping
    public List<Post> getPosts() {
        return postService.findAllPosts();
    }

    @GetMapping("/{id}")
    public Post getPostById(@PathVariable Long id) {
        return postService.findPostById(id);
    }

    @PostMapping
    public Post createPost(@RequestBody Post post) {
        return postService.savePost(post);
    }

    @PutMapping("/{id}")
    public Post updatePost(@PathVariable Long id, @RequestBody Post post) {
        Post existingPost = postService.findPostById(id);
        existingPost.setTitle(post.getTitle());
        existingPost.setContent(post.getContent());
        existingPost.setAuthor(post.getAuthor());
        return postService.savePost(existingPost);
    }

    @DeleteMapping("/{id}")
    public void deletePost(@PathVariable Long id) {
        postService.deletePost(id);
    }
}
```

---

### 2. **프론트엔드: React로 게시판 만들기**

React에서 백엔드 API와 통신하여 데이터를 표시하고 조작합니다.

#### React 프로젝트 생성
```shell script
npx create-react-app react-board
cd react-board
npm install axios react-router-dom
```

#### 폴더 구조
```
src
├── App.js
├── components
│   ├── PostForm.js
│   ├── PostList.js
│   └── PostDetail.js
├── services
│   └── api.js
└── pages
    ├── Home.js
    ├── PostCreate.js
    ├── PostEdit.js
    └── PostView.js
```

#### API 요청을 처리하는 `api.js`
```
import axios from "axios";

const API_URL = "http://localhost:8080/api/posts";

export const getPosts = () => axios.get(API_URL);
export const getPostById = (id) => axios.get(`${API_URL}/${id}`);
export const createPost = (post) => axios.post(API_URL, post);
export const updatePost = (id, post) => axios.put(`${API_URL}/${id}`, post);
export const deletePost = (id) => axios.delete(`${API_URL}/${id}`);
```

#### `PostList.js` (게시글 목록)
```
import React, { useEffect, useState } from "react";
import { getPosts } from "../services/api";
import { Link } from "react-router-dom";

const PostList = () => {
    const [posts, setPosts] = useState([]);

    useEffect(() => {
        getPosts().then((response) => setPosts(response.data));
    }, []);

    return (
        <div>
            <h1>게시판</h1>
            <Link to="/posts/create">새 글 작성</Link>
            <ul>
                {posts.map(post => (
                    <li key={post.id}>
                        <Link to={`/posts/${post.id}`}>{post.title}</Link>
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default PostList;
```

#### `PostForm.js` (글 작성/수정 폼)
```
import React, { useState } from "react";

const PostForm = ({ onSubmit, post }) => {
    const [title, setTitle] = useState(post?.title || "");
    const [content, setContent] = useState(post?.content || "");
    const [author, setAuthor] = useState(post?.author || "");

    const handleSubmit = (e) => {
        e.preventDefault();
        onSubmit({ title, content, author });
    };

    return (
        <form onSubmit={handleSubmit}>
            <div>
                <label>제목</label>
                <input value={title} onChange={(e) => setTitle(e.target.value)} />
            </div>
            <div>
                <label>내용</label>
                <textarea value={content} onChange={(e) => setContent(e.target.value)} />
            </div>
            <div>
                <label>작성자</label>
                <input value={author} onChange={(e) => setAuthor(e.target.value)} />
            </div>
            <button type="submit">저장</button>
        </form>
    );
};

export default PostForm;
```

#### `Home.js`
```
import React from "react";
import PostList from "../components/PostList";

const Home = () => {
    return (
        <div>
            <PostList />
        </div>
    );
};

export default Home;
```

#### 라우터 설정 (`App.js`)
```
import React from "react";
import { BrowserRouter as Router, Route, Routes } from "react-router-dom";
import Home from "./pages/Home";
import PostView from "./pages/PostView";
import PostCreate from "./pages/PostCreate";
import PostEdit from "./pages/PostEdit";

const App = () => {
    return (
        <Router>
            <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/posts/create" element={<PostCreate />} />
                <Route path="/posts/:id" element={<PostView />} />
                <Route path="/posts/:id/edit" element={<PostEdit />} />
            </Routes>
        </Router>
    );
};

export default App;
```

---

### 프론트엔드와 백엔드 연결
1. Spring Boot 서버를 실행합니다.
2. React 개발 서버(`npm start`) 실행 후, API 요청이 정상적으로 작동하는지 확인합니다.

---

이 프로젝트는 게시판의 기본 구성만을 포함하며, 추가적으로 인증(Authentication), 페이징(Pagination), 스타일링 등을 적용하여 완성도를 높일 수 있습니다.

## Me
페이징 처리와 댓글 달기 기능이 필요해 

## AI Assistant
페이징 처리와 댓글 달기 기능을 추가하는 방법을 구체적으로 설명하겠습니다. Spring Boot에서 페이징과 댓글 기능을 처리하고, React에서 이를 프론트엔드에서 구현하는 방식을 다룹니다.

---

## **1. 페이징 처리 (백엔드)**
Spring Data JPA가 제공하는 `Pageable` 인터페이스를 사용해 쉽고 빠르게 페이징 처리를 구현할 수 있습니다.

### **Post Repository 수정**
페이징 기능을 추가하려면 Spring Data JPA의 `findAll(Pageable pageable)`을 활용합니다.

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface PostRepository extends JpaRepository<Post, Long> {
    Page<Post> findAll(Pageable pageable);
}
```

### **PostApiController에서 페이징 처리**
컨트롤러에서 `Pageable`을 매개변수로 받아 요청된 페이지 데이터를 반환하도록 수정합니다.

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostApiController {

    private final PostService postService;

    @GetMapping
    public Page<Post> getPosts(Pageable pageable) {
        return postService.findPosts(pageable);
    }
}
```

### **PostService 수정**
서비스에서 페이징 처리를 담당합니다.

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

@Service
@RequiredArgsConstructor
public class PostService {

    private final PostRepository postRepository;

    public Page<Post> findPosts(Pageable pageable) {
        return postRepository.findAll(pageable);
    }
}
```

---

## **2. 댓글 기능 추가 (백엔드)**

댓글 기능을 위해 **Comment 엔티티**를 생성하고 Post와 연관관계를 설정합니다.

### **Comment 엔티티**
```java
package jpabook.jpashop.domain;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Setter @Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Comment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;

    private String author;

    @Lob // 텍스트 형태로 저장
    private String content;

    private LocalDateTime createdAt;

    @PrePersist
    public void prePersist() {
        this.createdAt = LocalDateTime.now();
    }
}
```

### **Post 엔티티 수정**
Post에서 댓글을 관리하기 위해 연관관계를 설정합니다.

```java
@OneToMany(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true)
private List<Comment> comments = new ArrayList<>();
```

### **Comment Repository**
```java
package jpabook.jpashop.repository;

import jpabook.jpashop.domain.Comment;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByPostId(Long postId); // 특정 게시글의 댓글 조회
}
```

### **Comment Controller**
REST API를 통해 댓글을 추가, 조회, 삭제합니다.

```java
package jpabook.jpashop.api;

import jpabook.jpashop.domain.Comment;
import jpabook.jpashop.service.CommentService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/comments")
@RequiredArgsConstructor
public class CommentApiController {

    private final CommentService commentService;

    @PostMapping
    public Comment addComment(@RequestBody Comment comment) {
        return commentService.saveComment(comment);
    }

    @GetMapping("/post/{postId}")
    public List<Comment> getComments(@PathVariable Long postId) {
        return commentService.findCommentsByPostId(postId);
    }

    @DeleteMapping("/{id}")
    public void deleteComment(@PathVariable Long id) {
        commentService.deleteComment(id);
    }
}
```

### **Comment Service**
```java
package jpabook.jpashop.service;

import jpabook.jpashop.domain.Comment;
import jpabook.jpashop.repository.CommentRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class CommentService {

    private final CommentRepository commentRepository;

    public Comment saveComment(Comment comment) {
        return commentRepository.save(comment);
    }

    public List<Comment> findCommentsByPostId(Long postId) {
        return commentRepository.findByPostId(postId);
    }

    public void deleteComment(Long id) {
        commentRepository.deleteById(id);
    }
}
```

---

## **3. 프론트엔드 추가 기능 (React)**

### **페이징 처리**
React에서 페이징 처리를 위해 페이지 번호를 상태로 관리하며 API 요청 시 이를 전달합니다.

#### PostList.js 수정
```
import React, { useState, useEffect } from "react";
import { getPosts } from "../services/api";
import { Link } from "react-router-dom";

const PostList = () => {
    const [posts, setPosts] = useState([]);
    const [page, setPage] = useState(0);
    const [totalPages, setTotalPages] = useState(1);

    useEffect(() => {
        getPosts(page).then((response) => {
            setPosts(response.data.content);
            setTotalPages(response.data.totalPages);
        });
    }, [page]);

    const handleNext = () => {
        if (page < totalPages - 1) setPage(page + 1);
    };

    const handlePrev = () => {
        if (page > 0) setPage(page - 1);
    };

    return (
        <div>
            <h1>게시판</h1>
            <Link to="/posts/create">새 글 작성</Link>
            <ul>
                {posts.map((post) => (
                    <li key={post.id}>
                        <Link to={`/posts/${post.id}`}>{post.title}</Link>
                    </li>
                ))}
            </ul>
            <button onClick={handlePrev} disabled={page === 0}>이전</button>
            <button onClick={handleNext} disabled={page === totalPages - 1}>다음</button>
        </div>
    );
};

export default PostList;
```

### API 수정 (페이징 추가)
`api.js`에서 페이징을 위한 `page` 쿼리를 추가합니다.
```
export const getPosts = (page) => axios.get(`${API_URL}?page=${page}`);
```

---

### **댓글 기능**

#### CommentList.js
```
import React, { useState, useEffect } from "react";
import { getComments, createComment, deleteComment } from "../services/api";

const CommentList = ({ postId }) => {
    const [comments, setComments] = useState([]);
    const [content, setContent] = useState("");

    useEffect(() => {
        getComments(postId).then((response) => setComments(response.data));
    }, [postId]);

    const handleSubmit = (e) => {
        e.preventDefault();
        createComment({ postId, content, author: "익명" }).then(() => {
            setContent("");
            getComments(postId).then((response) => setComments(response.data));
        });
    };

    const handleDelete = (id) => {
        deleteComment(id).then(() => {
            getComments(postId).then((response) => setComments(response.data));
        });
    };

    return (
        <div>
            <form onSubmit={handleSubmit}>
                <textarea value={content} onChange={(e) => setContent(e.target.value)} />
                <button type="submit">댓글 작성</button>
            </form>
            <ul>
                {comments.map((comment) => (
                    <li key={comment.id}>
                        <p>{comment.content} - {comment.author}</p>
                        <button onClick={() => handleDelete(comment.id)}>삭제</button>
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default CommentList;
```

#### API 수정 (댓글)
```
export const getComments = (postId) => axios.get(`${API_URL}/post/${postId}`);
export const createComment = (comment) => axios.post(`${API_URL}`, comment);
export const deleteComment = (id) => axios.delete(`${API_URL}/${id}`);
```

#### PostDetail.js 수정
댓글 리스트를 렌더링합니다.
```
import React from "react";
import CommentList from "../components/CommentList";

const PostDetail = ({ postId }) => {
    return (
        <div>
            {/* ...게시물 내용 렌더링... */}
            <CommentList postId={postId} />
        </div>
    );
};

export default PostDetail;
```

---

### 실행 확인
1. Spring Boot 서버를 실행합니다.
2. React 개발 서버를 실행 (`npm start`).
3. 게시글 목록과 페이징, 댓글 달기/보기 기능이 정상작동하는지 확인합니다.

---

페이징 및 댓글 기능이 작동하는 기본적인 게시판을 구현했습니다. 추가로 댓글의 수정 기능, 사용자 인증, 댓글 작성자의 이메일 인증 등을 통해 확장할 수도 있습니다. 😊

## Me
거기에 파일 첨부랑 파일 다운로드와 삭제 기능도 추가해줘, 파일 이름은 암호화 / 복호화도 해줘

## AI Assistant
파일 업로드, 다운로드, 삭제, 그리고 파일 이름의 암호화 및 복호화 기능을 Spring Boot와 React를 사용하여 구현하는 방법을 설명드리겠습니다. 아래는 기능 추가를 위한 단계별 작업입니다.

---

## 1. 파일 업로드/다운로드/삭제 (백엔드)

파일 시스템에 파일을 저장하고, 파일 이름을 암호화하여 보안성을 강화합니다.

### **1.1 파일 저장 디렉토리 설정**

`application.yml`에 파일 저장 경로를 정의합니다.

```yaml
file:
  upload-dir: ./uploads
```

---

### **1.2 암호화 유틸리티**

파일 이름을 암호화하고 복호화하기 위한 유틸리티를 생성합니다. 여기서는 Base64를 예로 들지만, 더 강력한 암호화를 위해 AES 알고리즘도 사용할 수 있습니다.

```java
package jpabook.jpashop.util;

import java.util.Base64;

public class FileNameEncryptor {
    
    // 파일 이름 암호화
    public static String encrypt(String fileName) {
        return Base64.getEncoder().encodeToString(fileName.getBytes());
    }

    // 파일 이름 복호화
    public static String decrypt(String encryptedFileName) {
        return new String(Base64.getDecoder().decode(encryptedFileName));
    }
}
```

---

### **1.3 파일 엔티티**

파일 정보를 저장하기 위한 엔티티를 생성합니다.

```java
package jpabook.jpashop.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Setter @Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FileEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String originalFileName; // 원본 파일 이름
    private String encryptedFileName; // 암호화된 파일 이름
    private String filePath; // 저장된 파일 경로
}
```

---

### **1.4 파일 리포지토리**

파일 엔티티의 CRUD 작업을 처리합니다.

```java
package jpabook.jpashop.repository;

import jpabook.jpashop.domain.FileEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface FileRepository extends JpaRepository<FileEntity, Long> {
}
```

---

### **1.5 파일 서비스**

파일 업로드, 다운로드, 암호화, 삭제를 처리하는 로직을 구현합니다.

```java
package jpabook.jpashop.service;

import jpabook.jpashop.domain.FileEntity;
import jpabook.jpashop.repository.FileRepository;
import jpabook.jpashop.util.FileNameEncryptor;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class FileService {

    private final FileRepository fileRepository;

    @Value("${file.upload-dir}")
    private String uploadDir;

    // 파일 업로드
    public FileEntity uploadFile(MultipartFile file) throws IOException {
        String originalFileName = file.getOriginalFilename();
        String encryptedFileName = FileNameEncryptor.encrypt(originalFileName);
        Path filePath = Paths.get(uploadDir + "/" + encryptedFileName);

        // 파일 저장
        file.transferTo(filePath.toFile());

        // 저장 정보 DB에 저장
        FileEntity fileEntity = FileEntity.builder()
                .originalFileName(originalFileName)
                .encryptedFileName(encryptedFileName)
                .filePath(filePath.toString())
                .build();
        return fileRepository.save(fileEntity);
    }

    // 파일 다운로드
    public byte[] downloadFile(String encryptedFileName) throws IOException {
        FileEntity fileEntity = fileRepository.findAll().stream()
                .filter(f -> f.getEncryptedFileName().equals(encryptedFileName))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("파일을 찾을 수 없습니다."));
        Path path = Paths.get(fileEntity.getFilePath());
        return Files.readAllBytes(path);
    }

    // 파일 삭제
    public void deleteFile(String encryptedFileName) {
        Optional<FileEntity> fileEntityOpt = fileRepository.findAll().stream()
                .filter(f -> f.getEncryptedFileName().equals(encryptedFileName))
                .findFirst();
        if (fileEntityOpt.isPresent()) {
            FileEntity fileEntity = fileEntityOpt.get();
            File file = new File(fileEntity.getFilePath());
            if (file.exists()) {
                file.delete();
            }
            fileRepository.delete(fileEntity);
        }
    }
}
```

---

### **1.6 파일 컨트롤러**

REST API를 통해 파일 업로드, 다운로드, 삭제 작업을 실행합니다.

```java
package jpabook.jpashop.api;

import jpabook.jpashop.service.FileService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/api/files")
@RequiredArgsConstructor
public class FileApiController {

    private final FileService fileService;

    // 파일 업로드
    @PostMapping("/upload")
    public ResponseEntity<?> uploadFile(@RequestParam("file") MultipartFile file) {
        try {
            return ResponseEntity.ok(fileService.uploadFile(file));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    // 파일 다운로드
    @GetMapping("/download/{encryptedFileName}")
    public ResponseEntity<?> downloadFile(@PathVariable String encryptedFileName) {
        try {
            byte[] fileBytes = fileService.downloadFile(encryptedFileName);
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + encryptedFileName + "\"")
                    .body(fileBytes);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    // 파일 삭제
    @DeleteMapping("/{encryptedFileName}")
    public ResponseEntity<?> deleteFile(@PathVariable String encryptedFileName) {
        try {
            fileService.deleteFile(encryptedFileName);
            return ResponseEntity.ok().body("파일 삭제 완료");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}
```

---

## 2. 프론트엔드: 파일 업로드/다운로드/삭제

React에서 파일 업로드, 다운로드, 삭제를 실행합니다.

---

### **2.1 파일 업로드/다운로드 서비스**

`api.js` 파일에 파일 관련 요청을 정의합니다.

```
import axios from "axios";
const FILE_API_URL = "http://localhost:8080/api/files";

// 파일 업로드
export const uploadFile = (file) => {
    const formData = new FormData();
    formData.append("file", file);
    return axios.post(`${FILE_API_URL}/upload`, formData, {
        headers: { "Content-Type": "multipart/form-data" },
    });
};

// 파일 다운로드
export const downloadFile = (encryptedFileName) => {
    return axios.get(`${FILE_API_URL}/download/${encryptedFileName}`, {
        responseType: "blob", // 파일 데이터를 바이너리로 받음
    });
};

// 파일 삭제
export const deleteFile = (encryptedFileName) => {
    return axios.delete(`${FILE_API_URL}/${encryptedFileName}`);
};
```

---

### **2.2 파일 업로드 컴포넌트**

React 컴포넌트에서 파일을 서버로 전송합니다.

```
import React, { useState } from "react";
import { uploadFile, downloadFile, deleteFile } from "../services/api";

const FileUpload = () => {
    const [file, setFile] = useState(null);

    const handleFileUpload = (e) => {
        e.preventDefault();
        if (file) {
            uploadFile(file).then((response) => {
                alert("업로드 완료!");
                console.log(response.data);
            });
        }
    };

    const handleFileDownload = (encryptedFileName) => {
        downloadFile(encryptedFileName).then((response) => {
            const url = window.URL.createObjectURL(new Blob([response.data]));
            const link = document.createElement("a");
            link.href = url;
            link.setAttribute("download", encryptedFileName); // 다운로드 파일 이름
            document.body.appendChild(link);
            link.click();
            link.remove();
        });
    };

    const handleFileDelete = (encryptedFileName) => {
        deleteFile(encryptedFileName).then(() => {
            alert("파일 삭제 완료!");
        });
    };

    return (
        <div>
            <h1>파일 업로드</h1>
            <form onSubmit={handleFileUpload}>
                <input type="file" onChange={(e) => setFile(e.target.files[0])} />
                <button type="submit">업로드</button>
            </form>

            {/* 파일 다운로드/삭제 테스트 */}
            <button onClick={() => handleFileDownload("ENCRYPTED_FILE_NAME")}>
                파일 다운로드
            </button>
            <button onClick={() => handleFileDelete("ENCRYPTED_FILE_NAME")}>
                파일 삭제
            </button>
        </div>
    );
};

export default FileUpload;
```

---

### **3. 실행 과정**

1. **Spring Boot 서버 실행**: `http://localhost:8080/api/files`로 API 호출.
2. **React에서 업로드 테스트**:
   - 파일을 선택하고 업로드 실행.
   - 파일 다운로드 및 삭제 테스트.
3. 업로드된 파일은 프로젝트 디렉토리의 `uploads/`에 저장됩니다.

---

### 결론

위 과정에서 **파일 암호화 이름 처리**와 **업로드/다운로드 로직**을 쉽게 구현할 수 있습니다. 필요하면 암호화 알고리즘(AES 등)을 Base64 대신 추가로 구현하거나 S3와 같은 클라우드 저장소로 확장 가능합니다. 😊

## Me
게시판의 권한도 설정하고 싶어

## AI Assistant
게시판에 권한 관리를 도입하려면 **사용자 인증(Authentication)**과 **권한 부여(Authorization)**를 구현해야 합니다. 이를 통해 게시글 작성, 수정, 삭제, 조회 등의 권한을 제어할 수 있습니다. Spring Security와 JWT 또는 OAuth2를 사용하여 구현하는 방법을 소개합니다.

---

### **1. 기본 구성**
권한 관리에는 **사용자(entity)**, **역할(entity)**, 그리고 **Spring Security**를 사용합니다.

---

### **2. 권한 역할 설정**

#### **2.1 사용자(User) 엔티티 정의**
사용자 정보를 저장하는 엔티티를 정의합니다.

```java
package jpabook.jpashop.domain;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    private String password;

    @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();
}
```

#### **2.2 역할(Role) 엔티티 정의**
사용자들에게 부여할 권한(역할)을 정의합니다.

```java
package jpabook.jpashop.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String name; // ROLE_USER, ROLE_ADMIN 등
}
```

---

### **3. Spring Security로 권한 관리**
Spring Security를 활용하여 사용자 인증과 권한 부여를 처리합니다.

#### **3.1 SecurityConfig 설정**
Spring Security의 설정 파일을 작성합니다.

```java
package jpabook.jpashop.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final UserDetailsService userDetailsService;

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfiguration)
            throws Exception {
        return authConfiguration.getAuthenticationManager();
    }
}
```

---

### **4. 사용자 인증(UserDetailsService 구현)**

Spring Security와 통합하기 위해 `UserDetailsService`를 구현합니다.

#### **4.1 UserDetailsService 구현**
사용자 정보를 가져와 인증 과정을 수행합니다.

```java
package jpabook.jpashop.service;

import jpabook.jpashop.domain.User;
import jpabook.jpashop.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
        return new org.springframework.security.core.userdetails.User(
                user.getUsername(), user.getPassword(), user.getRoles()
        );
    }
}
```

#### **4.2 User와 Role 엔티티에 추가 설정**
User와 Role 엔티티를 `GrantedAuthority`와 연결합니다. 이를 통해 Spring Security가 사용자의 역할(권한)을 인식할 수 있습니다.

```java
// User.java
@Override
public Collection<? extends GrantedAuthority> getAuthorities() {
    return roles.stream()
            .map(role -> new SimpleGrantedAuthority(role.getName()))
            .collect(Collectors.toList());
}

// Role.java
public class Role implements GrantedAuthority {
    @Override
    public String getAuthority() {
        return name;
    }
}
```

---

### **5. 권한 기반 API 컨트롤러 보호**

Spring Security를 사용해 특정 API를 보호합니다.

#### **5.1 게시글 작성/수정/삭제 권한**

권한에 따라 특정 사용자의 접근을 제한합니다. 예를 들어 **게시글은 일반 사용자(ROLE_USER)**도 작성할 수 있지만, **삭제는 관리자(ROLE_ADMIN)만** 허용합니다.

```java
package jpabook.jpashop.api;

import jpabook.jpashop.domain.Post;
import jpabook.jpashop.service.PostService;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostApiController {

    private final PostService postService;

    @PreAuthorize("hasRole('ROLE_USER')")
    @PostMapping
    public Post createPost(@RequestBody Post post) {
        return postService.savePost(post);
    }

    @PreAuthorize("hasRole('ROLE_ADMIN')")
    @DeleteMapping("/{id}")
    public void deletePost(@PathVariable Long id) {
        postService.deletePost(id);
    }
}
```

#### **5.2 Security 설정 변경**
`SecurityConfig`에 URL 접근 정책을 추가합니다.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.csrf().disable()
        .authorizeRequests()
        .antMatchers("/api/posts/**").authenticated() // 인증된 사용자만 접근 가능
        .antMatchers("/api/admin/**").hasRole("ADMIN") // 관리자만 접근 가능
        .anyRequest().permitAll() // 나머지는 모두 허용
        .and()
        .formLogin(); // 폼 로그인 지원
}
```

---

### **6. 테스트하기**

#### **6.1 기본 사용자와 역할 추가**

애플리케이션 시작 시 기본 사용자를 생성합니다. 이를 위해 `CommandLineRunner`를 사용합니다.

```java
import jpabook.jpashop.domain.Role;
import jpabook.jpashop.domain.User;
import jpabook.jpashop.repository.RoleRepository;
import jpabook.jpashop.repository.UserRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.Collections;

@Component
public class DataLoader implements CommandLineRunner {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;

    public DataLoader(UserRepository userRepository, RoleRepository roleRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public void run(String... args) throws Exception {
        Role adminRole = roleRepository.save(Role.builder().name("ROLE_ADMIN").build());
        Role userRole = roleRepository.save(Role.builder().name("ROLE_USER").build());

        userRepository.save(User.builder()
                .username("admin")
                .password(passwordEncoder.encode("admin"))
                .roles(Collections.singleton(adminRole))
                .build());

        userRepository.save(User.builder()
                .username("user")
                .password(passwordEncoder.encode("password"))
                .roles(Collections.singleton(userRole))
                .build());
    }
}
```

---

### **7. 프론트엔드 수정**

React에서 로그인 상태를 유지하고 권한별로 버튼(수정, 삭제)을 표시하도록 합니다.

#### **7.1 권한 기반 버튼 렌더링**
React에서 사용자가 **ROLE_USER**인지 **ROLE_ADMIN**인지 확인하고 버튼을 표시합니다.

```
import React from "react";

const PostActions = ({ post, userRole, onDelete }) => {
    return (
        <div>
            {userRole === "ROLE_USER" && <button>수정</button>}
            {userRole === "ROLE_ADMIN" && <button onClick={() => onDelete(post.id)}>삭제</button>}
        </div>
    );
};

export default PostActions;
```

#### **7.2 React 로그인/토큰 관리 추가**

React에서 JWT 토큰을 백엔드 로그인 API로 받아와 저장하거나, 외부 인증 서비스를 활용하세요.

---

### 결론

위 방법을 통해 Spring Security로 게시글 권한을 구성하고, React에서 프론트엔드와 권한 관리 로직을 확인할 수 있습니다.

1. **Spring Security**는 권한 관리를 쉽게 도와줍니다.
2. 관리 권한을 세분화하여 **ROLE_USER**, **ROLE_ADMIN** 등을 활용하세요.
3. 필요 시 JWT 또는 OAuth2를 추가해 더 안전한 인증 시스템을 구성합니다.

추가 구현이 필요하면 알려주세요! 😊

## Me
게시판 회원가입 기능도 추가해줘 비밀번호는 암호화 / 복호화 기능도 있어야해

## AI Assistant
회원가입 기능을 추가하고 비밀번호를 암호화할 필요가 있습니다. 비밀번호는 반드시 암호화되어 저장되어야 하며 복호화해서는 **안 됩니다**. 비밀번호는 인증(로그인) 시 입력된 비밀번호와 저장된 해시 값을 비교하는 방식으로 처리해야 보안상 안전합니다. Spring Security의 `BCryptPasswordEncoder`를 사용하여 구현하는 방법을 설명드리겠습니다.

아래는 `회원가입 기능`과 비밀번호 암호화 처리에 대한 구현 내용입니다.

---

## 1. 사용자(User) 엔티티 설정

`User` 엔티티는 회원 정보를 담고 있으며, 사용자 이름, 비밀번호, 이메일, 권한 등을 저장합니다.

```java
package jpabook.jpashop.domain;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true) // 사용자 이름은 고유해야 함
    private String username;

    @Column(nullable = false) // 비밀번호 필수
    private String password;

    @Column(nullable = false, unique = true) // 이메일도 고유해야 함
    private String email;

    @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();
}
```

---

## 2. 비밀번호 암호화 처리

**Spring Security**에서 제공하는 `BCryptPasswordEncoder`를 사용하여 비밀번호를 암호화합니다. 암호화된 비밀번호는 DB에 저장되며, 나중에 인증 과정에서 비교에 사용됩니다.

---

## 3. 회원가입 로직

### **3.1 UserRepository 작성**
`UserRepository`는 `User` 엔티티와 연결되어 사용자 정보를 저장 및 조회합니다.

```java
package jpabook.jpashop.repository;

import jpabook.jpashop.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
}
```

---

### **3.2 회원가입 API**

컨트롤러에 회원가입 API를 작성합니다. 사용자 등록 시 비밀번호를 암호화하여 저장합니다.

#### **UserRequest DTO**
회원가입 시 필요한 입력 데이터를 전달받기 위한 DTO(Data Transfer Object)를 작성합니다.

```java
package jpabook.jpashop.dto;

import lombok.Getter;
import lombok.Setter;

@Getter @Setter
public class UserSignupRequest {
    private String username;
    private String password;
    private String email;
}
```

#### **UserController**
회원가입 API를 작성합니다.

```java
package jpabook.jpashop.api;

import jpabook.jpashop.domain.Role;
import jpabook.jpashop.domain.User;
import jpabook.jpashop.dto.UserSignupRequest;
import jpabook.jpashop.repository.RoleRepository;
import jpabook.jpashop.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.Collections;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder; // 비밀번호 암호화를 위한 인코더

    // 회원가입 엔드포인트
    @PostMapping("/signup")
    public String signup(@RequestBody UserSignupRequest request) {
        // 사용자 이름과 이메일 중복 확인
        if (userRepository.findByUsername(request.getUsername()).isPresent()) {
            return "이미 존재하는 사용자 이름입니다.";
        }

        if (userRepository.findByEmail(request.getEmail()).isPresent()) {
            return "이미 존재하는 이메일입니다.";
        }

        // 기본 ROLE_USER 부여
        Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseThrow(() -> new IllegalStateException("기본 역할이 설정되어 있지 않습니다."));

        // 비밀번호 암호화
        String encryptedPassword = passwordEncoder.encode(request.getPassword());

        // 사용자 저장
        User user = User.builder()
                .username(request.getUsername())
                .password(encryptedPassword)
                .email(request.getEmail())
                .roles(Collections.singleton(userRole)) // 기본적으로 ROLE_USER 부여
                .build();

        userRepository.save(user);
        return "회원가입 완료!";
    }
}
```

---

### **3.3 RoleRepository 작성**

회원에게 ROLE_USER, ROLE_ADMIN 등의 역할을 부여할 수 있어야 합니다. `RoleRepository`를 구현합니다.

```java
package jpabook.jpashop.repository;

import jpabook.jpashop.domain.Role;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(String name);
}
```

---

## 4. 비밀번호 인증 처리

비밀번호는 복호화되지 않으므로, 사용자 로그인 시 사용자가 입력한 비밀번호를 DB에 저장된 해시 값과 비교해야 합니다. 이를 위해 Spring Security의 **PasswordEncoder.matches()** 메서드를 사용합니다.

```java
package jpabook.jpashop.service;

import jpabook.jpashop.domain.User;
import jpabook.jpashop.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public boolean login(String username, String rawPassword) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다."));

        // 입력된 비밀번호(rawPassword)와 암호화된 비밀번호 비교
        return passwordEncoder.matches(rawPassword, user.getPassword());
    }
}
```

---

## 5. Spring Security 설정

Spring Security 설정에서 암호화를 위한 `PasswordEncoder`를 빈으로 등록합니다.

```java
package jpabook.jpashop.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

## 6. 초기 데이터 설정

기본 역할(Role)을 데이터베이스에 등록합니다. 애플리케이션 실행 시 ROLE_USER와 ROLE_ADMIN을 추가하기 위해 `CommandLineRunner`를 사용합니다.

```java
package jpabook.jpashop;

import jpabook.jpashop.domain.Role;
import jpabook.jpashop.repository.RoleRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class DataInitializer implements CommandLineRunner {

    private final RoleRepository roleRepository;

    public DataInitializer(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }

    @Override
    public void run(String... args) throws Exception {
        // 기본 역할 등록
        if (roleRepository.findByName("ROLE_USER").isEmpty()) {
            roleRepository.save(Role.builder().name("ROLE_USER").build());
        }

        if (roleRepository.findByName("ROLE_ADMIN").isEmpty()) {
            roleRepository.save(Role.builder().name("ROLE_ADMIN").build());
        }
    }
}
```

---

## 7. 간단한 React 회원가입 프론트엔드 구현

React에서 회원가입 폼과 서버와의 통신을 작성합니다.

```
import React, { useState } from "react";
import axios from "axios";

const Signup = () => {
    const [form, setForm] = useState({
        username: "",
        password: "",
        email: ""
    });

    const handleChange = (e) => {
        const { name, value } = e.target;
        setForm({ ...form, [name]: value });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            const response = await axios.post("http://localhost:8080/api/auth/signup", form);
            alert(response.data);
        } catch (error) {
            console.error("회원가입 중 오류:", error);
        }
    };

    return (
        <div>
            <h1>회원가입</h1>
            <form onSubmit={handleSubmit}>
                <div>
                    <label>사용자 이름</label>
                    <input type="text" name="username" onChange={handleChange} required />
                </div>
                <div>
                    <label>비밀번호</label>
                    <input type="password" name="password" onChange={handleChange} required />
                </div>
                <div>
                    <label>이메일</label>
                    <input type="email" name="email" onChange={handleChange} required />
                </div>
                <button type="submit">회원가입</button>
            </form>
        </div>
    );
};

export default Signup;
```

---

## 8. 테스트

1. Spring Boot 서버 실행.
2. React 앱 실행 및 회원가입 테스트.
3. 회원가입 후, 데이터베이스에 사용자 정보가 암호화된 비밀번호와 함께 저장되는지 확인.

---

이제 회원가입 기능이 완성되었습니다. 각 역할(Role)에 따라 권한을 부여하고, 인증과 권한 관리를 Spring Security와 함께 확장할 수 있습니다. 😊
